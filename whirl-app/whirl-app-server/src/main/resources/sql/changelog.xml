<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
	xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
         http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd">

	<property
		name="date_now"
		value="sysdate"
		dbms="oracle" />
	<property
		name="date_now"
		value="now()"
		dbms="mysql" />
	<property
		name="date_now"
		value="now()"
		dbms="postgresql" />

	<changeSet
			id="1.0"
			author="otlichnosti@gmail.com"
			failOnError="true"
			dbms="oracle, postgresql">
		<createTable
			tableName="WHIRL_USERS"
			remarks="Stores user information">
			<column
				name="ID"
				type="number"
				remarks="Identifier">
				<constraints
					primaryKey="true"
					primaryKeyName="PK_WHIRL_USERS" />
			</column>
			<column
				name="DELETED"
				type="boolean"
				remarks="Deletion mark" />
			<column
				name="LOGIN"
				type="varchar(4000)"
				remarks="User login" />
			<column
				name="PASSWORD_HASH"
				type="varchar(4000)"
				remarks="BCRYPT hash of user's password" />
			<column
				name="NAME"
				type="varchar(4000)"
				remarks="Readable name of user. E.g. first name and last name." />
			<column
				name="EMAIL"
				type="varchar(4000)"
				remarks="Email" />
			<column
				name="CREATION_DATE"
				type="datetime"
				remarks="Record creation time" />
		</createTable>
		<createIndex
			indexName="IDX_WHIRL_USERS_L"
			tableName="WHIRL_USERS">
			<column name="LOGIN" />
		</createIndex>

		<createTable
			tableName="WHIRL_USER_APPS"
			remarks="Stores accesses of user to applications by application code">
			<column
				name="ID"
				type="number"
				remarks="Identifier">
				<constraints
					primaryKey="true"
					primaryKeyName="PK_WHIRL_USER_APPS" />
			</column>
			<column
				name="DELETED"
				type="boolean"
				remarks="Deletion mark" />
			<column
				name="R_WHIRL_USERS"
				type="number"
				remarks="User identifier from WHIRL_USERS table">
				<constraints foreignKeyName="FK_WHIRL_USER_APPS_RWU" />
			</column>
			<column
				name="APPLICATION_CODE"
				type="varchar(4000)"
				remarks="Application code" />
		</createTable>
		<createIndex
			indexName="IDX_WHIRL_USER_APPS_RWU"
			tableName="WHIRL_USER_APPS">
			<column name="R_WHIRL_USERS" />
		</createIndex>
		<addForeignKeyConstraint
			constraintName="FK_WHIRL_USER_APPS_RWU"
			baseTableName="WHIRL_USER_APPS"
			baseColumnNames="R_WHIRL_USERS"
			referencedTableName="WHIRL_USERS"
			referencedColumnNames="ID" />

		<createTable
			tableName="WHIRL_USER_GROUPS"
			remarks="Stores access of user to applications by application code">
			<column
				name="ID"
				type="number"
				remarks="Identifier">
				<constraints
					primaryKey="true"
					primaryKeyName="PK_WHIRL_USER_GROUPS" />
			</column>
			<column
				name="DELETED"
				type="boolean"
				remarks="Deletion mark" />
			<column
				name="R_WHIRL_USERS"
				type="number">
				<constraints foreignKeyName="FK_WHIRL_USER_GROUPS_RWU" />
			</column>
			<column
				name="GROUP_CODE"
				type="varchar(4000)"
				remarks="Group code" />
		</createTable>
		<createIndex
			indexName="IDX_WHIRL_USER_GROUPS_RWU"
			tableName="WHIRL_USER_GROUPS">
			<column name="R_WHIRL_USERS" />
		</createIndex>
		<addForeignKeyConstraint
			constraintName="FK_WHIRL_USER_GROUPS_RWU"
			baseTableName="WHIRL_USER_GROUPS"
			baseColumnNames="R_WHIRL_USERS"
			referencedTableName="WHIRL_USERS"
			referencedColumnNames="ID" />

		<insert tableName="WHIRL_USERS">
			<column
				name="ID"
				type="number"
				valueNumeric="0" />
			<column
				name="DELETED"
				type="boolean" />
			<column
					name="LOGIN"
					type="varchar(4000)"
					value="whirl-admin"/>
			<column
				name="PASSWORD_HASH"
				type="varchar(4000)"
				value="$2a$10$nKGxjGAypl/a5NxBqi80HuTcDnDSA36teTopj5wRfx22i9Sk1ttXW" />
			<column
				name="NAME"
				type="varchar(4000)"
				value="Administrator" />
			<column
				name="EMAIL"
				type="varchar(4000)" />
			<column
				name="CREATION_DATE"
				type="datetime"
				valueComputed="${date_now}" />
		</insert>
		<insert tableName="WHIRL_USER_GROUPS">
			<column
				name="ID"
				type="number"
				valueNumeric="0" />
			<column
				name="DELETED"
				type="boolean" />
			<column
				name="R_WHIRL_USERS"
				type="number"
				valueNumeric="0" />
			<column
				name="GROUP_CODE"
				type="varchar(4000)"
				value="whirl-editor-access-group" />
		</insert>

        <!-- PostgreSQL -->
        <sql dbms="postgresql">
            CREATE TYPE function_result AS
            (
            title varchar(32767),
            message varchar(32767),
            message_type varchar(32767),
            next_event varchar(32767),
            parameter_value hstore,
            parameter_list_title hstore,
            parameter_type hstore,
            parameter_component hstore,
            parameter_index hstore
            )
        </sql>

        <sql dbms="postgresql">
            CREATE TYPE function_input AS
            (
            parameter_value hstore,
            parameter_list_title hstore,
            parameter_row_list hstore,
            parameter_type hstore,
            parameter_component hstore,
            parameter_index hstore,
            parameter_name hstore
            )
        </sql>

        <sql dbms="postgresql">
            CREATE TYPE row_value AS
            (
            fid varchar(32767),
            selected boolean,
            checked boolean,
            expanded boolean
            )
        </sql>

        <createProcedure dbms="postgresql" procedureName="internal_next_index">
            CREATE OR REPLACE FUNCTION internal_next_index (
            p_result function_result)
            RETURNS integer
            AS
            $$
            DECLARE
            v_result integer;
            BEGIN
            SELECT count (*) INTO v_result FROM skeys (p_result.parameter_index);

            RETURN v_result;
            END;
            $$
            LANGUAGE plpgsql
        </createProcedure>

        <createProcedure dbms="postgresql" procedureName="add_parameter_varchar">
            CREATE OR REPLACE FUNCTION add_parameter_varchar (
            p_result function_result,
            p_code varchar,
            p_value varchar)
            RETURNS function_result
            AS
            $$
            DECLARE
            v_index integer;
            BEGIN
            v_index := internal_next_index (p_result);

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_index)) > 0
            THEN
            p_result.parameter_index :=
            p_result.parameter_index::hstore
            || hstore (v_index::varchar, p_code);
            ELSE
            p_result.parameter_index := hstore (v_index::varchar, p_code);
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_value)) > 0
            THEN
            p_result.parameter_value :=
            p_result.parameter_value::hstore || hstore (p_code, p_value);
            ELSE
            p_result.parameter_value := hstore (p_code, p_value);
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_type)) > 0
            THEN
            p_result.parameter_type :=
            p_result.parameter_type::hstore || hstore (p_code, 'STRING');
            ELSE
            p_result.parameter_type := hstore (p_code, 'STRING');
            END IF;

            RETURN p_result;
            END;
            $$
            LANGUAGE plpgsql
        </createProcedure>

        <createProcedure dbms="postgresql" procedureName="add_parameter_boolean">
            CREATE OR REPLACE FUNCTION add_parameter_boolean (
            p_result function_result,
            p_code varchar,
            p_value boolean)
            RETURNS function_result
            AS
            $$
            DECLARE
            v_index integer;
            v_value varchar;
            BEGIN
            v_index := internal_next_index (p_result);

            IF p_value IS NOT NULL
            THEN
            v_value := p_value::varchar;
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_index)) > 0
            THEN
            p_result.parameter_index :=
            p_result.parameter_index::hstore
            || hstore (v_index::varchar, p_code);
            ELSE
            p_result.parameter_index := hstore (v_index::varchar, p_code);
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_value)) > 0
            THEN
            p_result.parameter_value :=
            p_result.parameter_value::hstore || hstore (p_code, v_value);
            ELSE
            p_result.parameter_value := hstore (p_code, v_value);
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_type)) > 0
            THEN
            p_result.parameter_type :=
            p_result.parameter_type::hstore || hstore (p_code, 'BOOLEAN');
            ELSE
            p_result.parameter_type := hstore (p_code, 'BOOLEAN');
            END IF;

            RETURN p_result;
            END;
            $$
            LANGUAGE plpgsql
        </createProcedure>

        <createProcedure dbms="postgresql" procedureName="add_parameter_number">
            CREATE OR REPLACE FUNCTION add_parameter_number (
            p_result function_result,
            p_code varchar,
            p_value numeric)
            RETURNS function_result
            AS
            $$
            DECLARE
            v_index integer;
            v_value varchar;
            BEGIN
            v_index := internal_next_index (p_result);

            IF p_value IS NOT NULL
            THEN
            v_value := p_value::varchar;
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_index)) > 0
            THEN
            p_result.parameter_index :=
            p_result.parameter_index::hstore
            || hstore (v_index::varchar, p_code);
            ELSE
            p_result.parameter_index := hstore (v_index::varchar, p_code);
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_value)) > 0
            THEN
            p_result.parameter_value :=
            p_result.parameter_value::hstore || hstore (p_code, v_value);
            ELSE
            p_result.parameter_value := hstore (p_code, v_value);
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_type)) > 0
            THEN
            p_result.parameter_type :=
            p_result.parameter_type::hstore || hstore (p_code, 'NUMBER');
            ELSE
            p_result.parameter_type := hstore (p_code, 'NUMBER');
            END IF;

            RETURN p_result;
            END;
            $$
            LANGUAGE plpgsql
        </createProcedure>

        <createProcedure dbms="postgresql" procedureName="add_parameter_date">
            CREATE OR REPLACE FUNCTION add_parameter_date (
            p_result function_result,
            p_code varchar,
            p_value timestamp)
            RETURNS function_result
            AS
            $$
            DECLARE
            v_index integer;
            v_value varchar;
            BEGIN
            v_index := internal_next_index (p_result);

            IF p_value IS NOT NULL
            THEN
            v_value := to_char (p_value, 'DD.MM.YYYY HH24:MI:SS');
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_index)) > 0
            THEN
            p_result.parameter_index :=
            p_result.parameter_index::hstore
            || hstore (v_index::varchar, p_code);
            ELSE
            p_result.parameter_index := hstore (v_index::varchar, p_code);
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_value)) > 0
            THEN
            p_result.parameter_value :=
            p_result.parameter_value::hstore || hstore (p_code, v_value);
            ELSE
            p_result.parameter_value := hstore (p_code, v_value);
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_type)) > 0
            THEN
            p_result.parameter_type :=
            p_result.parameter_type::hstore || hstore (p_code, 'DATE');
            ELSE
            p_result.parameter_type := hstore (p_code, 'DATE');
            END IF;

            RETURN p_result;
            END;
            $$
            LANGUAGE plpgsql
        </createProcedure>

        <createProcedure dbms="postgresql" procedureName="add_parameter_list">
            CREATE OR REPLACE FUNCTION add_parameter_list (
            p_result function_result,
            p_code varchar,
            p_list_title varchar,
            p_list_value varchar)
            RETURNS function_result
            AS
            $$
            DECLARE
            v_index integer;
            BEGIN
            v_index := internal_next_index (p_result);

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_index)) > 0
            THEN
            p_result.parameter_index :=
            p_result.parameter_index::hstore
            || hstore (v_index::varchar, p_code);
            ELSE
            p_result.parameter_index := hstore (v_index::varchar, p_code);
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_list_title)) > 0
            THEN
            p_result.parameter_list_title :=
            p_result.parameter_list_title::hstore
            || hstore (p_code, p_list_title);
            ELSE
            p_result.parameter_list_title := hstore (p_code, p_list_title);
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_value)) > 0
            THEN
            p_result.parameter_value :=
            p_result.parameter_value::hstore || hstore (p_code, p_list_value);
            ELSE
            p_result.parameter_value := hstore (p_code, p_list_value);
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_type)) > 0
            THEN
            p_result.parameter_type :=
            p_result.parameter_type::hstore || hstore (p_code, 'LIST');
            ELSE
            p_result.parameter_type := hstore (p_code, 'LIST');
            END IF;

            RETURN p_result;
            END;
            $$
            LANGUAGE plpgsql
        </createProcedure>

        <createProcedure dbms="postgresql" procedureName="add_parameter_component">
            CREATE OR REPLACE FUNCTION add_parameter_component (
            p_result function_result,
            p_code varchar,
            p_component_code varchar)
            RETURNS function_result
            AS
            $$
            DECLARE
            v_index integer;
            BEGIN
            v_index := internal_next_index (p_result);

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_index)) > 0
            THEN
            p_result.parameter_index :=
            p_result.parameter_index::hstore
            || hstore (v_index::varchar, p_code);
            ELSE
            p_result.parameter_index := hstore (v_index::varchar, p_code);
            END IF;

            IF (SELECT count (*)
            FROM skeys (p_result.parameter_component)) > 0
            THEN
            p_result.parameter_component :=
            p_result.parameter_component::hstore
            || hstore (p_code, p_component_code);
            ELSE
            p_result.parameter_component := hstore (p_code, p_component_code);
            END IF;

            RETURN p_result;
            END;
            $$
            LANGUAGE plpgsql
        </createProcedure>

        <createProcedure dbms="postgresql" procedureName="set_message">
            CREATE OR REPLACE FUNCTION set_message (
            p_result function_result,
            p_title varchar,
            p_message varchar,
            p_message_type varchar DEFAULT 'INFO')
            RETURNS function_result
            AS
            $$
            DECLARE
            v_index integer;
            BEGIN
            p_result.title := p_title;
            p_result.message := p_message;
            p_result.message_type := p_message_type;
            RETURN p_result;
            END;
            $$
            LANGUAGE plpgsql
        </createProcedure>

        <createProcedure dbms="postgresql" procedureName="return">
            CREATE OR REPLACE FUNCTION return (p_result function_result)
            RETURNS varchar
            AS
            $$
            DECLARE
            v_result hstore;

            v_parameter_array hstore [];
            v_parameter hstore;

            v_parameter_rec record;
            v_parameter_index integer;
            v_parameter_code varchar (4000);
            v_parameter_type varchar (4000);
            BEGIN
            v_result := ''::hstore;

            IF p_result.message IS NOT NULL
            THEN
            v_result := v_result || hstore ('message', p_result.message);
            v_result := v_result || hstore ('title', p_result.title);
            v_result := v_result || hstore ('messageType', p_result.message_type);
            END IF;

            IF p_result.next_event IS NOT NULL
            THEN
            v_result := v_result || hstore ('nextEvent', p_result.next_event);
            END IF;

            v_parameter_array := '{}';
            v_parameter_index := 0;

            FOR v_parameter_rec IN (SELECT *
            FROM each (p_result.parameter_index))
            LOOP
            v_parameter_index := v_parameter_index + 1;

            v_parameter := ''::hstore;

            v_parameter :=
            v_parameter || hstore ('index', v_parameter_index::varchar);

            v_parameter_code := p_result.parameter_index -> v_parameter_rec.key;
            v_parameter := v_parameter || hstore ('code', v_parameter_code);

            IF exist (p_result.parameter_component, v_parameter_code)
            THEN
            v_parameter := v_parameter || hstore('component', p_result.parameter_component -> v_parameter_code);
            ELSE
            v_parameter_type := p_result.parameter_type -> v_parameter_code;
            v_parameter := v_parameter || hstore ('type', v_parameter_type);

            IF v_parameter_type = 'LIST'
            THEN
            v_parameter := v_parameter || hstore('title', p_result.parameter_list_title -> v_parameter_code);
            END IF;

            v_parameter := v_parameter || hstore('value', p_result.parameter_value -> v_parameter_code);
            END IF;

            v_parameter_array[v_parameter_index] := v_parameter;
            END LOOP;

            RETURN rtrim (to_json (v_result)::varchar, '}')
            || ', "parameters": '
            || to_json (v_parameter_array)
            || '}';
            END;
            $$
            LANGUAGE plpgsql
        </createProcedure>


        <!-- Oracle -->


        <rollback>

            <!-- PostgreSQL -->
            <sql dbms="postgresql">
                DROP TYPE function_result
            </sql>
            <sql dbms="postgresql">
                DROP TYPE function_input
            </sql>
            <sql dbms="postgresql">
                DROP TYPE function_input
            </sql>
            <sql dbms="postgresql">
                DROP TYPE row_value
            </sql>
            <sql dbms="postgresql">
                DROP FUNCTION internal_next_index (
                p_result function_result)
            </sql>
            <sql dbms="postgresql">
                DROP FUNCTION add_parameter_varchar (
                p_result function_result,
                p_code varchar,
                p_value varchar)
            </sql>
            <sql dbms="postgresql">
                DROP FUNCTION add_parameter_boolean (
                p_result function_result,
                p_code varchar,
                p_value boolean)
            </sql>
            <sql dbms="postgresql">
                DROP FUNCTION add_parameter_number (
                p_result function_result,
                p_code varchar,
                p_value numeric)
            </sql>
            <sql dbms="postgresql">
                DROP FUNCTION add_parameter_date (
                p_result function_result,
                p_code varchar,
                p_value timestamp)
            </sql>
            <sql dbms="postgresql">
                DROP FUNCTION add_parameter_list (
                p_result function_result,
                p_code varchar,
                p_list_title varchar,
                p_list_value varchar)
            </sql>
            <sql dbms="postgresql">
                DROP FUNCTION add_parameter_component (
                p_result function_result,
                p_code varchar,
                p_component_code varchar)
            </sql>
            <sql dbms="postgresql">
                DROP FUNCTION set_message (
                p_result function_result,
                p_title varchar,
                p_message varchar,
                p_message_type varchar DEFAULT 'INFO')
            </sql>
            <sql dbms="postgresql">
                DROP FUNCTION return (
                p_result function_result)
            </sql>

            <!-- Oracle -->

            <dropForeignKeyConstraint baseTableName="WHIRL_USER_GROUPS" constraintName="FK_WHIRL_USER_GROUPS_RWU"/>
			<dropIndex tableName="WHIRL_USER_GROUPS" indexName="IDX_WHIRL_USER_GROUPS_RWU"/>
			<dropTable tableName="WHIRL_USER_GROUPS"/>

			<dropForeignKeyConstraint baseTableName="WHIRL_USER_APPS" constraintName="FK_WHIRL_USER_APPS_RWU"/>
			<dropIndex tableName="WHIRL_USER_APPS" indexName="IDX_WHIRL_USER_APPS_RWU"/>
			<dropTable tableName="WHIRL_USER_APPS"/>

			<dropIndex tableName="WHIRL_USERS" indexName="IDX_WHIRL_USERS_L"/>
			<dropTable tableName="WHIRL_USERS"/>
		</rollback>
	</changeSet>

</databaseChangeLog>